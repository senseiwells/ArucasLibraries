//Class PosWithFun and Class Direction
//suggest having as NORTH = new Direction('north');, since enum does not work properly atm.
import Java from util.Internal;

NORTH = new Direction('north');
SOUTH = new Direction('south');
WEST = new Direction('west');
EAST = new Direction('east');
UP = new Direction('up');
DOWN = new Direction('down');

class PosWithFun {
    var x;
    var y;
    var z;
    var shape = null;
    var render = false;
    PosWithFun(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    PosWithFun(pos){
        this.x = pos.getX();
        this.y = pos.getY();
        this.z = pos.getZ();
    }
    fun getX(){
        //compat with pos
        return this.x;
    }
    fun getY(){
        return this.y;
    }
    fun getZ(){
        return this.z;
    }
    fun add(other){
        return new PosWithFun(this.x + other.getX(), this.y + other.getY(), this.z + other.getZ());
    }
    fun subtract(other){
        return new PosWithFun(this.x - other.getX(), this.y - other.getY(), this.z - other.getZ());
    }
    fun distanceTo(otherPos){
        dx = otherPos.getX() - this.x;
        dy = otherPos.getY() - this.y;
        dz = otherPos.getZ() - this.z;
        return (dx ^2 + dy ^2 + dz ^2) ^ 0.5;
    }
    fun isNear(entity){
        pos = entity.getPos();
        dist = this.distanceTo(pos);
        return dist < 4.5;//player reach
    }
    fun asCenter(){
        return new PosWithFun(this.x + 0.5, this.y + 0.5, this.z + 0.5);
    } // sometimes you need this?
    fun getSidePos(direction){ //for Wall Mounted Blocks vanilla protocol
        //we expect Direction object here
        return this.asCenter().offset(direction, 0.5);
    }
    fun isNear(entity, distance){
        pos = entity.getPos();
        return this.distanceTo(pos) < distance;
    }
    fun mult(integer){
        return new PosWithFun(this.x * integer, this.y * integer, this.z * integer);
    }
    fun asPos(){
        return new Pos(this.x, this.y, this.z);
    }
    fun asJavaPos(){
        return Java.constructClass('net.minecraft.util.math.BlockPos',this.x, this.y, this.z);
    }//conversion
    fun formatted(){
        return 'x '+ this.x + ' y' + this.y + ' z' + this.z;
    }
    fun copy(){
        return new PosWithFun(this.x, this.y, this.z);
    }
    fun offset(direction){
        //south +z north -z west -x east +x
        return this.add(direction.asVector());
    }
    fun offset(direction, amount){
        return this.add(direction.asVector().mult(amount));
    }
    fun up(){
        return this.add(new Direction('up'));
    }
    fun down(){
        return this.add(new Direction('down'));
    }
    fun up(int){
        return this.add(new Direction('up').mult(int));
    }
    fun down(int){
        return this.add(new Direction('down').mult(int));
    }
    fun getMinPos(otherPos){ //Compare two positions to get Minimum position (Box)
        return new PosWithFun(Math.min(this.x, otherPos.x),Math.min(this.y, otherPos.y),Math.min(this.z, otherPos.z) );
    }
    fun getMaxPos(otherPos){
        return new PosWithFun(Math.max(this.x, otherPos.x),Math.max(this.y, otherPos.y),Math.max(this.z, otherPos.z) );
    }
    fun equals(otherPos){
        return this.x == otherPos.x && this.y == otherPos.y && this.z == otherPos.z;
    }
}
class Direction {
    var vector;
    var pointer;
    var fromString;
    var axis;
    var id;
    static var rotateYClockwiseArr = ['south', 'west', 'north', 'east'];
    Direction(fromString){
        fromString = fromString.lowercase();
        if (fromString == 'south'){
            this.vector = new PosWithFun(0,0,+1);
            this.pointer = 0;
            this.axis = "Z";
            this.id = 3;
        }
        else if (fromString == 'north'){
            this.vector = new PosWithFun(0,0,-1);
            this.pointer = 2;
            this.axis = "Z";
            this.id = 2;
        }
        else if (fromString == 'east'){
            this.vector = new PosWithFun(1,0,0);
            this.pointer = 3;
            this.axis = "X";
            this.id = 5;
        }
        else if (fromString == 'west'){
            this.vector = new PosWithFun(-1,0,0);
            this.pointer = 1;
            this.axis = "X";
            this.id = 4;
        }
        else if (fromString == 'up'){
            this.vector = new PosWithFun(0,1,0);
            this.pointer = null;
            this.axis = "Y";
            this.id = 1;
        }
        else if (fromString == 'down'){
            this.vector = new PosWithFun(0,-1,0);
            this.pointer = null;
            this.axis = "Y";
            this.id = 0;
        }
        else {
            this.vector = null;
            this.axis = null;
        }
        this.fromString = fromString;
    }
    fun rotateYClockwise(){
        return new Direction(Direction.rotateYClockwiseArr.get(Math.mod(this.pointer + 1, 4)));
    }
    fun rotateYCounterclockwise(){
        return new Direction(Direction.rotateYClockwiseArr.get(Math.mod(this.pointer - 1, 4)));
    }
    fun getOpposite(){
        if (this.pointer == null){
            if (this.fromString == 'up'){
                return new Direction('down');
            }
            return new Direction('up');
        }
        return new Direction(Direction.rotateYClockwiseArr.get(Math.mod(this.pointer + 2, 4)));
    }
    fun getX(){
        return this.vector.getX();
    }
    fun getY(){
        return this.vector.getY();
    }
    fun getZ(){
        return this.vector.getZ();
    }
    fun asVector(){
        return this.vector.copy();
    }
    fun equals(other){
        return this.fromString == other.fromString;
    }
    fun isValid(){
        return this.vector != null;
    }
    fun mult(integer){
        return this.vector.mult(integer);
    }
    static fun values(){
        return [ UP, DOWN, NORTH, SOUTH, EAST, WEST];
    }
    static fun horizontal(){
        return [NORTH, SOUTH, EAST, WEST];
    }
}

class PosWithDirection{
    var x;
    var y;
    var z;
    var direction = null;
    PosWithDirection(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    PosWithDirection(x, y, z, direction){
        this.x = x;
        this.y = y;
        this.z = z;
        this.direction = direction;
    }
    PosWithDirection(pos){
        this.x = pos.getX();
        this.y = pos.getY();
        this.z = pos.getZ();
    }
    PosWithDirection(pos, direction){
        this.x = pos.getX();
        this.y = pos.getY();
        this.z = pos.getZ();
        this.direction = direction;
    }
    fun getX(){
        //compat with pos
        return this.x;
    }
    fun getY(){
        return this.y;
    }
    fun getZ(){
        return this.z;
    }
    fun getDirection(){
        return this.direction;
    }
    fun add(other){
        return new PosWithDirection(this.x + other.getX(), this.y + other.getY(), this.z + other.getZ(), this.direction);
    }
    fun subtract(other){
        return new PosWithDirection(this.x - other.getX(), this.y - other.getY(), this.z - other.getZ(), this.direction);
    }
    fun distanceTo(otherPos){
        dx = otherPos.getX() - this.x;
        dy = otherPos.getY() - this.y;
        dz = otherPos.getZ() - this.z;
        return (dx ^2 + dy ^2 + dz ^2) ^ 0.5;
    }
    fun isNear(entity){
        pos = entity.getPos();
        dist = this.distanceTo(pos);
        return dist < 4.5;//player reach
    }
    fun asCenter(){
        return new PosWithFun(this.x + 0.5, this.y + 0.5, this.z + 0.5);
    } // sometimes you need this?
    fun getSidePos(direction){ //for Wall Mounted Blocks vanilla protocol
        //we expect Direction object here
        return this.asCenter().offset(direction, 0.5);
    }
    fun isNear(entity, distance){
        pos = entity.getPos();
        return this.distanceTo(pos) < distance;
    }
    fun mult(integer){
        return new PosWithDirection(this.x * integer, this.y * integer, this.z * integer, this.direction);
    }
    fun asPos(){
        return new Pos(this.x, this.y, this.z);
    }
    fun asJavaPos(){
        return Java.constructClass('net.minecraft.util.math.BlockPos',this.x, this.y, this.z);
    }//conversion
    fun formatted(){
        return 'x '+ this.x + ' y' + this.y + ' z' + this.z + ' ' + this.direction.fromString;
    }
    fun copy(){
        return new PosWithDirection(this.x, this.y, this.z);
    }
    fun offset(direction){
        //south +z north -z west -x east +x
        return this.add(direction.asVector());
    }
    fun offset(direction, amount){
        return this.add(direction.asVector().mult(amount));
    }
    fun up(){
        return this.add(new Direction('up'));
    }
    fun down(){
        return this.add(new Direction('down'));
    }
    fun getMinPos(otherPos){ //Compare two positions to get Minimum position (Box)
        return new PosWithDirection(Math.min(this.x, otherPos.x),Math.min(this.y, otherPos.y),Math.min(this.z, otherPos.z) );
    }
    fun getMaxPos(otherPos){
        return new PosWithDirection(Math.max(this.x, otherPos.x),Math.max(this.y, otherPos.y),Math.max(this.z, otherPos.z) );
    }
    fun equals(otherPos){
        return this.x == otherPos.x && this.y == otherPos.y && this.z == otherPos.z;
    }
}
