//import * from Minecraft;
//import Java from util.Internal;
import * from PosUtils;
import Java from util.Internal;

NORTH = new Direction('north');
SOUTH = new Direction('south');
WEST = new Direction('west');
EAST = new Direction('east');
UP = new Direction('up');
DOWN = new Direction('down');

//Piston Utils
class PistonUtils{
    var world;
    PistonUtils(world){
        this.world = world;
    }
    static fun canExtend(world, pos, facing){
        return world.getBlockAt(pos.offset(facing).asPos()).isReplaceable() && world.getBlockAt(pos.asPos()).isReplaceable();
    }
    static fun canPlaceTorchPoweringPiston(world, pos, facing){
    //returns Facing of Torch
        if (!world.getBlockAt(pos.asPos()).isReplaceable()){
            return null;
        }
        foreach (direction : Direction.values()){
            if (direction.equals(facing)){
                continue;
            }
            if (direction.axis == 'y'){
                clickPos = blockPos.offset(DOWN);
                if (!world.getBlockAt(clickPos.asPos()).sideCoversSmallSquare(UP)){
                    continue;
                }
            }
            else {
                clickPos = blockPos.offset(torchFacing.getOpposite());
                if (!world.getBlockAt(clickPos.asPos()).sideCoversSmallSquare(facing.fromString)){
                    continue;
                }
            }
            return direction;
        }
        return null;
    }
    static fun getHorizontalQcCheck(world, offsetFromPiston, pistonPos, pistonFacing){
        // returns new PosWithDirection(startPos, validFacing)
        // piston offset as 'startPos', then check with rotations and offset, to power piston.
        // means this function just iterates over piston's one side to get powering torch postion.
        startPos = pistonPos.offset(offsetFromPiston); //we offset from piston with direction, and this direction is restricted
	    if(PistonUtils.requiredOffsetCheck(world, startPos, 'torch', DOWN) && PistonUtils.willPowerPiston(startPos, DOWN, pistonPos, pistonFacing)) {
            return new PosWithDirection(startPos, DOWN);
	    }
	    foreach (torchTestFacing : Direction.values()){
	        if( torchTestFacing.equals(UP) || offsetFromPiston.equals(torchTestFacing) || offsetFromPiston.equals(pistonFacing)) {
	            continue; //restricted
	        }
	    	foreach(offB : [0,1]){
	    		torchPos = startPos.up(offB);
	    		torchAble = PistonUtils.requiredOffsetCheck(world, torchPos, 'torch', torchTestFacing);
	    		if(torchAble && PistonUtils.willPowerPiston(torchPos, torchTestFacing, pistonPos, pistonFacing)) {
	    			return new PosWithDirection(torchPos, torchTestFacing);
	    	    }
	    	}
	    }
	    return null;
    }
    static fun calculateValidTorchPos(world, pistonPos, pistonFacing){
        foreach (directions : Direction.horizontal() ){
            result = PistonUtils.getHorizontalQcCheck(world, directions, pistonPos, pistonFacing);
            if (result != null){
                return result;
            }
            if (!pistonFacing.equals(UP) && PistonUtils.requiredOffsetCheck(world, pistonPos.up(), 'torch', directions)){
                return new PosWithDirection(pistonPos.up(), directions);
            }
        }
        if (!pistonFacing.equals(DOWN) && PistonUtils.checkCanPlaceAt(world, pistonPos.down(), ItemStack.of(Material.of('torch')).asBlock())){
            return new PosWithDirection(pistonPos.down(), DOWN);
        }
    }
    static fun calculateBreakingPiston(world, blockPos){
        foreach ( directions : Direction.values()){
            pistonPos = blockPos.offset(directions);
            finalFacing = directions.getOpposite();
            foreach ( pistonFacing : Direction.values()){
                if (finalFacing.equals(pistonFacing) || !PistonUtils.canExtend(world, pistonPos, pistonFacing)){
                    continue;
                }
                result = PistonUtils.calculateValidTorchPos(world, pistonPos, pistonFacing);
                if (result != null && PistonUtils.willPowerPiston(new PosWithFun(result.asPos()), result.direction, pistonPos, finalFacing)){
                    return new recordPiston(pistonFacing, finalFacing, result.direction, pistonPos, new PosWithFun(result.asPos()));
                }
            }
        }
        return null;
    }
    static fun calculateBreakingPiston(world, blockPos, finalFacing){
        foreach ( directions : [finalFacing]){
            pistonPos = blockPos.offset(finalFacing.getOpposite());
            finalFacing = directions;
            foreach ( pistonFacing : Direction.values()){
                if (finalFacing.equals(pistonFacing) || !PistonUtils.canExtend(world, pistonPos, pistonFacing)){
                    continue;
                }
                result = PistonUtils.calculateValidTorchPos(world, pistonPos, pistonFacing);
                if (result != null && PistonUtils.willPowerPiston(new PosWithFun(result.asPos()), result.direction, pistonPos, finalFacing)){
                    return new recordPiston(pistonFacing, finalFacing, result.direction, pistonPos, new PosWithFun(result.asPos()));
                }
            }
        }
        return null;
    }
    static fun willPowerPiston(posTorch, faceTorch, posPiston, facePiston){
	    if (posPiston.offset(facePiston).equals(posTorch)) {
	        return false;
	    }
	    if (posTorch.offset(faceTorch.getOpposite()).equals(posPiston) || posTorch.offset(faceTorch.getOpposite()).equals(posPiston.up())){
	        return false;
	    }
	    if (posPiston.up().equals(posTorch)){
	        return false;
	    }
	    if ( posPiston.down().equals(posTorch)){
	        return true;
	    }
	    if (facePiston.axis == 'y'){
	        foreach ( directions : Direction.horizontal()){
	            foreach (offsets : [0,1]){
	                off = posPiston.offset(directions).offset(UP, offsets);
	                if ( off.equals(posTorch)){
	                    return true;
	                }
	            }
	        }
	    }
	    foreach ( directions : Direction.horizontal()){
	        foreach ( offsets : [0,1]){
	            if (offsets == 0 && directions.equals(facePiston) && posPiston.offset(directions).equals(posTorch)){
	                return false;
	            }
	            off = posPiston.offset(directions).offset(UP, offsets);
	            if (off.equals(posTorch)){
	                return true;
	            }
	        }
	    }
	    return false;
    }
    static fun requiredOffsetCheck(world, blockPos, itemString, torchFacing){
        //WallMountedBlock, we need library maybe?
        if (torchFacing == null){
            torchFacing = new Direction("down");
        }
        if (itemString.contains('torch') && torchFacing.axis != 'Y'){
            clickPos = blockPos.offset(torchFacing.getOpposite());
            if (!world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).isReplaceable() || !world.getBlockAt(clickPos.getX(),clickPos.getY(),clickPos.getZ()).sideCoversSmallSquare(torchFacing.fromString)){
                return false;
            }
        }
        else {
            return PistonUtils.checkCanPlaceAt(world, blockPos, ItemStack.of(Material.of(itemString)).asBlock());
        }
        return true;
    }
    static fun checkCanPlaceAt(world, position, block){
        if (!world.getBlockAt(position.asPos()).isReplaceable()){
            return false;
        }
        jBlock = Java.valueOf(block); //blockState
        jWorld = Java.valueOf(world);
        jPosition = position.asJavaPos();
        return jBlock.getBlock().canPlaceAt(jBlock, jWorld, jPosition).toArucas();
    }
}

class recordPiston{
    var pistonFacing;
    var finalFacing;
    var torchFacing;
    var pistonPos;
    var torchPos;
    recordPiston(pistonFacing, pistonFinalFacing, torchFacing, pistonPos, torchPos){
        this.pistonFacing = pistonFacing;
        this.finalFacing = pistonFinalFacing;
        this.torchFacing = torchFacing;
        this.pistonPos = pistonPos;
        this.torchPos = torchPos;
    }
    fun formatted(){
        return 'Piston at '+ this.pistonPos.formatted() + ' with initial facing ' + this.pistonFacing.fromString + ' with final facing ' + this.finalFacing.fromString + '\nTorch at ' + this.torchPos.formatted() + ' with facing '+ this.torchFacing.fromString;
    }
}