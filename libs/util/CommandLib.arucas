//Check Argument has Unique names, prevent client crash

client = MinecraftClient.getClient();

//functions for argParse
fun checkArguments(iterable){
    argNames = Set.of();
    foreach( i : iterable){
        if  ( argNames.contains(i)){
            throwRuntimeError("Arguments name should have unique names!");
        }
        argNames.add(i);
    }
}

//Very handy command builder
//lambda as fun(){something;}
//NextedCommand([ArgList], lambda).build() to get 'built' one, .debugBuild() to get 'string' format, .process() to process and register command.
//new NestedCommand([['eDemiBolt'], ['x', 'Integer'],['y', 'Integer'],['z', 'Integer'], ['direction', 'Word', ['north', 'west', 'east', 'south']]], demiBoltTask).process();

class Queue {
    var asList;
    Queue(fromList){
        this.asList = [];
        this.asList.addAll(fromList.copy());
    }
    fun pop(){
        if(len(this.asList) == 0){
            return null;
        }
        val = this.asList.get(0);
        this.asList.remove(0);
        return val;
    }
    fun popLast(){
        pointer = len(this.asList);
        if(pointer == 0){
            return null;
        }
        val = this.asList.get(pointer - 1);
        this.asList.remove(pointer - 1);
        return val;
    }
    fun hasItems(){
        return !this.asList.isEmpty();
    }
}

class NestedCommand{
    var waitingQueue;
    var lambda;
    var command;
    var innerDebug = '';
    var innerScope;
    var recursionCount;
    NestedCommand(arguments, lambda){
        // [<a>, <a,b>, <a,b>,...] -> root a, arguments with type b executes lambda
        checkArguments(arguments);
        this.innerDebug = '';
        this.waitingQueue = new Queue(arguments);
        this.lambda = lambda;
        this.recursionCount = 0;
    }
    NestedCommand(queue, lambda, innerScope, recursionCount){
        // [<a>, <a,b>, <a,b>,...] -> root a, arguments with type b executes lambda
        this.waitingQueue = queue;// inherits queue
        this.lambda = lambda;
        this.innerDebug = '';
        this.innerScope = innerScope;
        this.recursionCount = recursionCount;
        if (recursionCount > 15){
            throwRuntimeError("Argument count maximum is set to 15");
        }
    }
    NestedCommand(queue, lambda, innerScope, recursionCount, innerDebug){
        // [<a>, <a,b>, <a,b>,...] -> root a, arguments with type b executes lambda
        this.waitingQueue = queue;// inherits queue
        this.lambda = lambda;
        this.innerScope = innerScope;
        this.innerDebug = innerDebug;
        this.recursionCount = recursionCount;
        if (recursionCount > 15){
            throwRuntimeError("Argument count maximum is set to 15");
        }
    }
    fun build(){
        current = this.waitingQueue.popLast();
        if (current == null){
            return this.innerScope;
        }
        //we got something as List anyway.
        tempCommand = '';
        if (len(current) == 1){
            tempCommand = CommandBuilder.literal(current.get(0));
        }
        else if (len(current) == 2) {
            tempCommand = CommandBuilder.argument(current.get(0), current.get(1));
        }
        else if (len(current) == 3){
            //suggest args
            tempCommand = CommandBuilder.argument(current.get(0), current.get(1), current.get(2));
        }
        else if (len(current) > 3){
            messageHolder.sendMessage(current);
            throwRuntimeError("Argument was not type of List<ArgName, ArgType, Suggestions> or List<ArgName, ArgType> or list<ArgName>");
        }

        newInnerScope = null;
        if (this.innerScope != null){
            newInnerScope = tempCommand.then(this.innerScope);
        }
        else {
            newInnerScope = tempCommand;
        }
        if (this.lambda != null){
            newInnerScope = newInnerScope.executes(this.lambda); //Terminal execution
        }
        return new NestedCommand(this.waitingQueue, null, newInnerScope, this.recursionCount + 1).build();
    }
    fun debugBuild(){
        current = this.waitingQueue.popLast();
        if (current == null){
            return this.innerDebug;
        }
        //we got something as List anyway.
        tempCommand = '';
        if (len(current) == 1){
            tempCommand = 'CommandBuilder.literal(' + current.get(0) + ')';
        }
        else if (len(current) == 2) {
            tempCommand = 'CommandBuilder.argument(' + current.get(0) + ',' +  current.get(1)+ ')';
        }
        else if (len(current > 3)) {
            messageHolder.sendMessage(current);
            throwRuntimeError("Argument was not type of List<ArgName, ArgType, Suggestions> or List<ArgName, ArgType> or list<ArgName>");
        }
        else if (len(current) == 3){
            //suggest args
            tempCommand = 'CommandBuilder.argument(' + current.get(0) + ',' +  current.get(1)+ ',' + current.get(2)+')';
        }
        newInnerDebug = '';
        if (this.innerDebug != ''){
            newInnerDebug = tempCommand + '.then('+ this.innerDebug + ')';
        }
        else {
            newInnerDebug = tempCommand;

        }
        if (this.lambda != null){
            newInnerDebug = newInnerDebug + '.executes(lambda)';
        }
        return (new NestedCommand(this.waitingQueue, null, null, this.recursionCount + 1, newInnerDebug)).debugBuild();
    }
    fun process(){
        client.addCommand(this.build());
    }
}